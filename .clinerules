# Cert-Watch Project Guidelines

This document outlines the guiding principles, workflows, and coding standards
for the Cert-Watch project. Adhering to these rules ensures consistency,
quality, and maintainability.

## 1. Guiding Principles & Workflow

This section covers the high-level philosophy and processes that govern the
project.

### 1.1. Project Hygiene

-   **No Artifacts:** No build artifacts, log files, or other generated files
should be committed to the repository.
-   **Cleanliness Over Complexity:** Less code is better than more code. Always
aim for simplicity and clarity.
-   **Rewrite Over Add:** Prefer refactoring an existing component to meet a
new requirement over adding a new, duplicative one.
-   **Flag Obsolete Code:** If a file or block of code becomes obsolete during
a refactoring, it should be explicitly flagged for deletion in the commit
message or a follow-up task.

### 1.2. Version Control

-   **Suggest Structured Commit Messages:** When a task is complete, suggest a
clear, well-structured commit message that follows the **Conventional Commits**
specification and the **50/72 rule**.
    -   **Structure:** `type(scope): subject` line, an optional detailed
    description, and an optional footer for tags and references, all separated
    by blank lines.
    -   **Example:**
        ```text
        feat(dns): Add dual-curve retry logic

        Implement separate exponential backoff strategies for standard
        DNS failures (timeouts/server errors) and NXDOMAIN responses.
        This prevents spamming resolvers for non-existent domains.

        Ticket: CERT-15
        ```

### 1.3. Task Completion Protocol

Follow these steps sequentially to ensure a clean and validated handoff of completed work.

1.  **Update Plan:** Mark the corresponding task(s) as complete (e.g., `[x]`)
in `docs/plan.md`.
2.  **Validate Changes:** Run the full test suite (`cargo test --all-features`)
to ensure no regressions have been introduced.
3.  **Propose Commit:** Propose a well-structured commit message that adheres
to the project's version control conventions.
4.  **Await User Approval:** Do not proceed to the next task until the user has
explicitly confirmed that they have tested the application's functionality and
approved the changes. This serves as a formal handoff and validation gate.

---

## 2. Environment & Tooling

This section defines the development environment and how to interact with
external code and libraries.

### 2.1. Nix Environment

-   All development happens within the environment defined in `flake.nix` and
managed by `direnv`. The necessary toolchains (e.g., the Rust compiler) are
assumed to be available in the shell.

### 2.2. Library Usage

-   **Verify Library References:** When referencing external libraries,
double-check that the referenced classes, methods, or fields actually exist. Do
not guess or hallucinate API names.
-   **Consult Authoritative Documentation:** To find the correct version or API
for a crate, consult its documentation. The primary method is to generate a
local copy using `cargo doc -p crate-name --no-deps
--target-dir=./data/rustdocs`. If local documentation is insufficient or online
access is required, use the terminal-based browser as a fallback: `nix run
nixpkgs#links2 -- -dump https://docs.rs/cratename/latest/cratename/`.

---

## 3. Rust Coding Standards

This section contains specific rules and best practices for writing Rust code
in this project.

### 3.1. API and Type Design

-   **Use Borrowed Types for Arguments:** Functions should prefer accepting
borrowed types over owned types to increase flexibility and avoid unnecessary
allocations (e.g., `&str` over `&String`, `&[T]` over `&Vec<T>`).
-   **Return Consumed Arguments on Error:** If a fallible function takes
ownership of an argument, the `Err` variant of its `Result` should return the
argument to the caller, allowing for recovery and retry logic without cloning.
-   **Builder Pattern for Complex Construction:** For structs with multiple
optional fields or complex initialization logic, provide a `builder()` method
that returns a dedicated builder struct. This is preferred over a multitude of
`new_with_*` constructors.
-   **Newtype Pattern for Type Safety:** Use the newtype pattern (e.g., `struct
UserId(u64);`) to leverage the type system for creating distinct,
domain-specific types from primitives. This prevents logic errors, such as
swapping a `UserId` with a generic `u64`.
-   **RAII for Resource Management:** Use the RAII (Resource Acquisition Is
Initialization) pattern with "guard" objects to manage resources that require
explicit cleanup. The resource should be released in the guard's `Drop`
implementation.

### 3.2. Error Handling & Concurrency

-   **Propagate Errors Explicitly:** Do not use fallback mechanisms that hide
failures. Use `Result<T, E>` and the `?` operator to propagate errors up the
call stack. Errors should only be handled at the highest appropriate layer
(e.g., the top of a running task), never ignored or replaced with default
values.
-   **Prioritize Message Passing for Concurrency:** To manage shared state and
avoid race conditions, the primary strategy must be message passing using
channels (e.g., `tokio::sync::mpsc`). Direct shared-state primitives like
`Arc<Mutex<T>>` should only be used in specific, well-justified cases, such as
for read-mostly data like a shared configuration.

### 3.3. Testing Strategy

-   **Follow Test-Driven Development (TDD):** Tests must be written before the
implementation code.
-   **Test Structure:**
    -   **Unit Tests:** Place these inside a `#[cfg(test)] mod tests { ... }`
    block within the same file as the code they test.
    -   **Integration Tests:** Place these in the top-level `/tests` directory.
-   **Dependency Isolation:** For unit tests, the primary strategy must be
**Trait-Based Dependency Injection** with hand-written "fake" implementations.
Mocking libraries should only be used as a secondary tool when verifying the
exact nature of an interaction is critical.
-   **Hermetic Integration Tests:** When using the `TestAppBuilder` for
integration tests, all external dependencies and side-effects must be mocked
(e.g., `with_dns_resolver`, `with_enrichment_provider`, `with_websocket`,
`with_outputs`). The goal is a fully controlled, deterministic test
environment.
-   **Prefer Focused Unit Tests:** Business logic must be tested with focused
unit tests. Avoid broad "end-to-end" tests for verifying small pieces of
functionality.
-   **Avoid `tokio::time::sleep` for Synchronization:** Using `sleep` for
synchronization in tests is forbidden. Use deterministic primitives like
`tokio::sync::Barrier` or `tokio::sync::oneshot` instead.

### 3.4. Code Structure & Safety

-   **Contain `unsafe` Code:** All `unsafe` code must be encapsulated within
the smallest possible module. This module must expose a minimal, safe API, and
every `unsafe` block must be justified with a `// SAFETY:` comment.
-   **Prefer Small, Focused Crates:** Decompose large projects into smaller,
more focused crates that each do one thing well.
-   **Decompose Structs for Better Borrowing:** If a large struct is causing
borrow checker issues, consider decomposing it into smaller, cohesive structs.

### 3.5. Anti-Patterns to Avoid

-   **Avoid Cloning to Satisfy the Borrow Checker:** Do not use `.clone()` as a
first resort to fix borrow checker errors. Refactor the code to manage
lifetimes correctly first.
-   **Do Not Use `Deref` for Inheritance:** The `Deref` trait should be used
for smart pointer types, not to simulate inheritance.
-   **Do Not Use `#![deny(warnings)]` in Libraries:** This can cause downstream
projects to fail to build. Use a CI pipeline with `RUSTFLAGS="-D warnings"` to
enforce a no-warning policy during development instead.
